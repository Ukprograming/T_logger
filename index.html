<!-- FILE: index.html (T_logger build v9) -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DS18B20 温度ロガー (Web Serial)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .row { display:flex; flex-wrap: wrap; gap:8px; align-items: center; }
    label { margin-right: 8px; }
    #log { white-space: pre; max-height: 200px; overflow:auto; background:#f7f7f7; padding:8px; border:1px solid #ddd; }
    button { padding:6px 12px; }
    input, select { padding:4px 6px; }
  </style>
</head>
<body>
  <h1>DS18B20 温度ロガー (Web Serial)</h1>
  <div class="row">
    <button id="connectBtn">ポート接続</button>
    <button id="disconnectBtn" disabled>切断</button>
    <label>分解能：
      <select id="resSel">
        <option value="12" selected>12-bit (～0.0625℃ / 750ms)</option>
        <option value="11">11-bit (～0.125℃ / 375ms)</option>
        <option value="10">10-bit (～0.25℃ / 188ms)</option>
        <option value="9">9-bit (～0.5℃ / 94ms)</option>
      </select>
    </label>
    <label>周期(ms)：<input type="number" id="periodIn" value="1000" min="50" step="50"></label>
    <label>表示ウィンドウ(分)：<input type="number" id="windowMin" value="10" min="1" step="1"></label>
  </div>
  <div class="row" style="margin-top:8px;">
    <button id="startBtn" disabled>記録開始</button>
    <button id="stopBtn" disabled>停止</button>
    <button id="markBtn" disabled>マーカー</button>
    <button id="clearBtn">表示クリア</button>
    <button id="downloadBtn" disabled>CSVダウンロード</button>
    <button id="scanBtn" disabled>再スキャン (SCAN/HEADER)</button>
  </div>
  <p id="status">未接続</p>
  <canvas id="chart" height="120"></canvas>
  <h3>受信ログ</h3>
  <div id="log"></div>

<script>
'use strict';
console.log('T_logger build v9');

// --------- Chart.js 準備 ---------
const ctx = document.getElementById('chart').getContext('2d');
const chart = new Chart(ctx, {
  type: 'line',
  data: { labels: [], datasets: [] },
  options: {
    animation: false,
    parsing: false,
    normalized: true,
    spanGaps: true,
    interaction: { mode: 'nearest', intersect: false },
    plugins: { legend: { display: true, position: 'bottom' } },
    scales: {
      x: { type: 'linear', display: false }, // 自前で時刻を持つ
      y: { title: { display: true, text: 'Temperature (°C)' } }
    }
  }
});

// Chart.js の更新ヘルパ
function ensureDatasets(n) {
  while (chart.data.datasets.length < n) {
    chart.data.datasets.push({
      label: `T${chart.data.datasets.length}`,
      data: [],
      fill: false,
      borderWidth: 1,
      pointRadius: 0
    });
  }
}
function trimWindow(windowMs) {
  const cutoff = performance.now() - windowMs;
  chart.data.datasets.forEach(ds => {
    while (ds.data.length && ds.data[0].x < cutoff) ds.data.shift();
  });
}
function pushSample(tsPerf, temps) {
  ensureDatasets(temps.length);
  temps.forEach((t, i) => {
    if (t == null || !Number.isFinite(t)) return; // 無効値は捨てる
    chart.data.datasets[i].data.push({ x: tsPerf, y: t });
  });
  chart.update('none');
}

// --------- Web Serial ---------
let port, reader, writer, readLoopActive = false;
let lineBuf = '';
let sensorCount = 0;
let startPerfBase = performance.now();
let csvRows = []; // [timestamp_iso, ...temps]
let running = false;

// epoch 換算の基準（古いブラウザ対策含む）
const timeOriginMs = (typeof performance.timeOrigin === 'number')
  ? performance.timeOrigin
  : (Date.now() - performance.now());

const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const markBtn = document.getElementById('markBtn');
const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');
const scanBtn = document.getElementById('scanBtn');
const resSel = document.getElementById('resSel');
const periodIn = document.getElementById('periodIn');
const windowMin = document.getElementById('windowMin');

function log(s) {
  logEl.textContent += s + '\n';
  logEl.scrollTop = logEl.scrollHeight;
}
function setUIConnected(yes) {
  connectBtn.disabled = yes;
  disconnectBtn.disabled = !yes;
  startBtn.disabled = !yes;
  stopBtn.disabled = !yes;
  markBtn.disabled = !yes;
  downloadBtn.disabled = !yes;
  scanBtn.disabled = !yes;
}

// ---- 送信は「TextEncoder + port.writable」方式 ----
const encoder = new TextEncoder();
async function sendLine(s) {
  if (!writer) return;
  console.log('TX>', s);
  await writer.write(encoder.encode(s + '\n'));
}

async function connect() {
  try {
    if (!('serial' in navigator)) {
      alert('このブラウザは Web Serial に未対応です（Chrome/Edge を使用してください。HTTPS 必須）');
      return;
    }
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });

    // 受信側：TextDecoderStreamで文字列に
    const textDecoder = new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable);
    reader = textDecoder.readable.getReader();

    // 送信側：生の writable にバイト列を書き込む
    writer = port.writable.getWriter();

    setUIConnected(true);
    statusEl.textContent = '接続中';
    statusEl.style.color = '';
    log('# Connected');

    // 初期設定をデバイスへ
    await sendLine(`RES ${resSel.value}`);
    await sendLine(`PERIOD ${periodIn.value}`);
    await sendLine('SCAN');
    await sendLine('HEADER');

    readLoopActive = true;
    readLoop();
  } catch (e) {
    console.error(e);
    alert('接続に失敗: ' + e);
  }
}

async function disconnect() {
  readLoopActive = false;
  try { if (reader) await reader.cancel(); } catch {}
  try { if (writer) writer.releaseLock(); } catch {}
  try { if (reader) reader.releaseLock(); } catch {}
  try { if (port)   await port.close(); } catch {}
  setUIConnected(false);
  statusEl.textContent = '未接続';
  statusEl.style.color = '';
  log('# Disconnected');
}

// ---- ヘッダ行の超防御型パーサ ----
function parseHeaderLine(raw) {
  try {
    const line = String(raw).replace(/\uFEFF/g, '').trim();

    // # SENSORS : n
    if (/^#\s*SENSORS\b/i.test(line)) {
      const colon = line.indexOf(':');
      const after = colon >= 0 ? line.slice(colon + 1).trim() : '';
      const n = Number.parseInt(after, 10);
      sensorCount = Number.isFinite(n) ? n : 0;
      ensureDatasets(sensorCount);
      chart.update();
      statusEl.textContent = (sensorCount > 0) ? `検出センサ: ${sensorCount}` : 'センサ未検出（配線/ピン/抵抗を確認）';
      statusEl.style.color = (sensorCount > 0) ? '' : 'crimson';
      return;
    }

    // # SENSOR<idx> : <rom>
    if (/^#\s*SENSOR\b/i.test(line)) {
      const colon = line.indexOf(':');
      const left = colon >= 0 ? line.slice(0, colon) : line;
      const right = colon >= 0 ? line.slice(colon + 1) : '';
      const idxStr = left.replace(/^#\s*SENSOR/i, '').trim();
      const idx = Number.parseInt(idxStr, 10);
      const rom = right.trim();

      if (Number.isFinite(idx) && chart.data.datasets[idx]) {
        chart.data.datasets[idx].label = `T${idx} (${rom})`;
      }
      return;
    }

    // その他の # 行は無視
  } catch (e) {
    console.warn('parseHeaderLine failed:', raw, e);
  }
}

// ---- データ行パーサ（NaN完全防御＋ISO変換安全化）----
function parseDataLine(line) {
  // 例: 12345,25.062,24.812
  const parts = line.split(',');
  if (parts.length < 2) return;

  // timestamp_ms
  const tsMs = Number.parseInt(parts[0].trim(), 10);
  if (!Number.isFinite(tsMs)) {
    console.warn('Invalid timestamp, skip:', parts[0]);
    return;
  }

  // 温度群
  const temps = [];
  for (let i = 1; i < parts.length; i++) {
    const sv = parts[i].trim();
    const v = sv === '' ? NaN : Number.parseFloat(sv);
    temps.push(Number.isFinite(v) ? v : null);
  }

  // パフォーマンス時間に載せて描画
  const windowMs = Math.max(1, Number.parseInt(windowMin.value, 10)) * 60_000;
  const tsPerf = startPerfBase + tsMs; // performance.now() ベースの相対時刻
  pushSample(tsPerf, temps);
  trimWindow(windowMs);

  // CSV 用に ISO（エポックへ安全に変換）
  const epochMs = timeOriginMs + tsPerf;
  if (Number.isFinite(epochMs)) {
    try {
      const iso = new Date(epochMs).toISOString();
      csvRows.push([iso, ...temps]);
    } catch (e) {
      console.warn('ISO conversion failed for', epochMs, e);
    }
  } else {
    console.warn('epochMs is not finite, skip CSV');
  }
}

async function readLoop() {
  while (readLoopActive) {
    const { value, done } = await reader.read();
    if (done) break;
    lineBuf += value;
    let idx;
    while ((idx = lineBuf.indexOf('\n')) >= 0) {
      const line = lineBuf.slice(0, idx).replace(/\r$/, '');
      lineBuf = lineBuf.slice(idx + 1);
      if (!line) continue;

      if (line.startsWith('#')) {
        try { parseHeaderLine(line); }
        catch (e) { console.warn('Header parse error:', line, e); }
        log(line);
        continue;
      }
      parseDataLine(line);
    }
  }
}

// --------- UI handlers ---------
connectBtn.onclick = connect;
disconnectBtn.onclick = disconnect;
scanBtn.onclick = async () => { await sendLine('SCAN'); await sendLine('HEADER'); };

startBtn.onclick = async () => {
  await sendLine(`RES ${resSel.value}`);
  await sendLine(`PERIOD ${periodIn.value}`);
  await sendLine('START');
  running = true;
  statusEl.textContent = '記録中';
  statusEl.style.color = '';
  log('# START');
};
stopBtn.onclick = async () => {
  await sendLine('STOP');
  running = false;
  statusEl.textContent = '停止';
  statusEl.style.color = '';
  log('# STOP');
};
markBtn.onclick = () => {
  const ts = new Date().toISOString();
  log(`# MARK ${ts}`);
};
clearBtn.onclick = () => {
  chart.data.datasets.forEach(ds => ds.data = []);
  chart.update();
  csvRows = [];
  log('# Cleared');
};
downloadBtn.onclick = () => {
  const header = ['timestamp_iso'];
  for (let i = 0; i < chart.data.datasets.length; i++) header.push(`T${i}_C`);
  const lines = [header.join(',')];
  for (const row of csvRows) lines.push(row.join(','));
  const blob = new Blob(["\uFEFF" + lines.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `ds18b20_log_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
  a.click();
  URL.revokeObjectURL(url);
};

// ページ離脱時は安全に切断
window.addEventListener('beforeunload', async () => { try { await disconnect(); } catch {} });
</script>
</body>
</html>
